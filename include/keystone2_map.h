/* Copyright (C) 2014 Texas Instruments Incorporated - http://www.ti.com/
 *
 *
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions
 *  are met:
 *
 *    Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 *    Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the
 *    distribution.
 *
 *    Neither the name of Texas Instruments Incorporated nor the names of
 *    its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */

#ifndef _KEYSTONE2_MAP_H
#define _KEYSTONE2_MAP_H
/************************************************************************************
 * FILE PURPOSE: Define the register set and memory maps for keystone2 devices
 ************************************************************************************
 * FILE NAME: keystone2_map.h
 *
 * DESCRIPTION: Defines the keystone2 memory map and peripheral address.
 *
 *              !!!!!!!!
 *              This file should never be included directly.
 *              !!!!!!!!
 *
 *              All files should include device.h, which is generated by the
 *              make process. device.h will include this file along with gem_map.h
 *
 *              keystone2 memory map information should be placed here. Only values
 *              that don't match the definitions in gem_map.h need to go here. 
 *              Definitions here will override those in gem_map.h
 *
 ************************************************************************************/

#include "types.h"

#define DEVICE_REG_ADDR_BOOT_PROGRESS  0x02620140

#define DEVICE_REG_BOOT_COMPLETE      *((volatile unsigned int *)0x0262013c)
#define DEVICE_REG_BOOT_PROGRESS      *((volatile unsigned int *)0x02620140)

#define DEVICE_ADDR_RESET_STAT        0x02620144
#define DEVICE_REG_RESET_STAT         *((volatile unsigned int *)DEVICE_ADDR_RESET_STAT)

#define DEVICE_ADDR_RESET_STAT_CLEAR  0x02620134
#define DEVICE_REG_RESET_STAT_CLEAR   *((volatile unsigned int *)DEVICE_ADDR_RESET_STAT_CLEAR)

#define DEVICE_ADDR_POWER_STATE_CTL   0x2620150
#define DEVICE_REG_POWER_STATE_CTL    *((volatile unsigned int *)DEVICE_ADDR_POWER_STATE_CTL)

#define DEVICE_ADDR_IPCGR_BASE        0x2620240
#define DEVICE_ADDR_IPCGR(x)          (DEVICE_ADDR_IPCGR_BASE + ((x)*4))
#define DEVICE_REG_IPCGR(x)           *((volatile unsigned int *)DEVICE_ADDR_IPCGR(x))

#define DEVICE_ADDR_IPCAR_BASE        0x2620280
#define DEVICE_REG_IPCAR(x)           *((volatile unsigned int *)(DEVICE_ADDR_IPCAR_BASE + ((x)*4)))

#define DEVICE_ADDR_IPCGRH            0x0262027c
#define DEVICE_ADDR_IPCARH            0x026202bc
#define DEVICE_REG_IPCGRH             *((volatile unsigned int *)DEVICE_ADDR_IPCGRH)
#define DEVICE_REG_IPCARH             *((volatile unsigned int *)DEVICE_ADDR_IPCARH)

#define DEVICE_REG_MISC_CTL           *((volatile unsigned int *)0x02620700)
#define DEVICE_REG_MISC_CTL1          *((volatile unsigned int *)0x02620c7c)
#define DEVICE_ADDR_DISABLE_STAT      0x0262012c
#define DEVICE_REG_DISABLE_STAT       *((volatile unsigned int *)DEVICE_ADDR_DISABLE_STAT)
#define DEVICE_REG_PCIE_VENDOR_ID     *((volatile unsigned int *)0x02620128)
#define DEVICE_REG_DEVCFG             *((volatile unsigned int *)0x0262014c)

#define DEVICE_REG_BIT_RESET_STAT_GLOBAL_MSB      31
#define DEVICE_REG_BIT_RESET_STAT_GLOBAL_LSB      31
#define DEVICE_REG_FIELD_RESET_STAT_GLOBAL_RESET   1

#define DEVICE_REG_BOOT_ADDRESS(x)    *(((volatile unsigned int *)0x02620040 + (x)*0x20))
#define DEVICE_ADDR_BOOT_ADDRESS(x)   (0x02620040 + ((x)*0x4))

#define DEVICE_REG_DEVSTAT_ADDR       0x02620020  /* gem_map.h defines DEVICE_REG_DEVSTAT to access the reg*/
#define DEVICE_REG_DEVSTAT            *((volatile UINT32 *)DEVICE_REG_DEVSTAT_ADDR)

#define DEVICE_REG_DIEID_ADDR         0x02620008  /* The die ID */

#define DEVICE_REG_DEVID_ADDR         0x02620018  /* Called JTAG ID in the spec */

#define DEVICE_REG_KICK0              0x02620038  /* Kick registers must be written before writing to */
#define DEVICE_REG_KICK1              0x0262003c  /* the chip level registers */

#define DEVICE_REG_ADDR_PLL_LOCK_STAT 0x2620718
#define DEVICE_REG_ADDR_PLL_LOCK_EVAL 0x262071c

#define DEVICE_REG_KICK0_MAGIC        0x83e70b13  /* The magic kick values */
#define DEVICE_REG_KICK1_MAGIC        0x95a4f1e0

#define DEVICE_ARM_ROM_START          0x00000000
#define DEVICE_ARM_ROM_END            0x00040000

#define DEVICE_FIELD_MISC_CTL1_ARM_PLL_EN_MSB       13
#define DEVICE_FIELD_MISC_CTL1_ARM_PLL_EN_LSB       13
#define DEVICE_VAL_MISC_CTL1_ARM_PLL_ENABLE          1

#define DEVICE_FIELD_MISC_CTL_DDR3_PSC_LOCK_EN_MSB  11
#define DEVICE_FIELD_MISC_CTL_DDR3_PSC_LOCK_EN_LSB  11
#define DEVICE_VAL_MISC_CTL1_DDR3_PSC_EN             1


#define DEVICE_MAX_ARMS     4
#define DEVICE_NUM_ARM_CLUSTERS     1

/* Map the ARM core number (0-3) to DNUM (8-11) */
#define DEVICE_ARM_CORE_DNUM(x)     ((x)+8)


/*** Device ID register bit fields ***
 /-------------------------------------------------\
 | 31   28 | 27        12 | 11             1 |  0  |
 | variant | part number  | Manufacturing ID | lsb |
 \-------------------------------------------------/
 ***/
#define DEVICE_FIELD_DEVID_VARIANT_MSB  31
#define DEVICE_FIELD_DEVID_VARIANT_LSB  28

#define DEVICE_FIELD_DEVID_PARTNUM_MSB  27
#define DEVICE_FIELD_DEVID_PARTNUM_LSB  12



/*** Disable stat register bit fields ***
 /---------------------------------------------------------------------------------------------
 | 31  30 |  29  |  28   | 27  |  26 | 25  | 24  |   23   |   22   |  21   |  20   |   19  |    18     |   17    |   16    |
 |  rsvd  | tsip | vusr2 | usb | aif | bcp | fftccd | fftcab | tcpcd | tcpab | raccd | racabtacd | vcpefgh | vcpabcd | 
 \---------------------------------------------------------------------------------------------
 
  ---------------------------------------------\
  | 15  |  14   | 13 |   12   | 11  8 | 7   0 |
  | xge | ddr3b | sa | tetris |  A15  |  Gem  |
  ---------------------------------------------/
 
 ***/
 
#define DEVICE_FIELD_DISABLE_TETRIS_MSB     12
#define DEVICE_FIELD_DISABLE_TETRIS_LSB     12

#define DEVICE_FIELD_DISABLE_ARM(x)         (8+(x))
#define DEVICE_FIELD_DISABLE_GEM(x)         (x)

#define DEVICE_FIELD_DISABLE_FFTC_AB_MSB    22
#define DEVICE_FIELD_DISABLE_FFTC_AB_LSB    22

#define DEVICE_FIELD_DISABLE_FFTC_CD_MSB    23
#define DEVICE_FIELD_DISABLE_FFTC_CD_LSB    23

#define DEVICE_FIELD_DISABLE_VUSR2_MSB      28
#define DEVICE_FIELD_DISABLE_VUSR2_LSB      28

#define DEVICE_FIELD_DISABLE_DDR3B_MSB      14
#define DEVICE_FIELD_DISABLE_DDR3B_LSB      14

#define DEVICE_VAL_DISABLE_REG_ENABLED      0
#define DEVICE_VAL_DISABLE_REG_DISABLED     1


/***  Devcfg register bits
 /------------------------------------------------------------\
 | 31  3 | 4                3 | 2              1 |     0      |
 |  rsvd | pciess mode port 1 |pciess mode port 0| sysclk out |
 \------------------------------------------------------------/
 ***/

#define DEVICE_DEVCFG_FIELD_PCIESS_MODE_MSB(port)       (2 + ((port) * 2))
#define DEVICE_DEVCFG_FIELD_PCIESS_MODE_LSB(port)       (1 + ((port) * 2))

#define DEVICE_VAL_DEVCFG_PCIESS_MODE_EP          0
#define DEVICE_VAL_DEVCFG_PCIESS_MODE_LEGACY_EP   1
#define DEVICE_VAL_DEVCFG_PCIESS_MODE_RC          2


/***  Misc CTL register
 /--------------------------------------------------------------------------------
 | 31 28 |    27     |     26    |  25    19  |    18   |    17    |          |
 | rsvd  | efuse act | efuse red | rst iso ip | usb pme | aet mux1 | aet mux0 |
 \--------------------------------------------------------------------------------
 
 -----------------------------------------------------------------------------\
      15     |    14     |   13      |          12       | 11 3 |  1        0 |
     rsvd    | raccd dis | racab dis | msmc parity block | rsvd | qm priority |
 -----------------------------------------------------------------------------/
***/
#define DEVICE_MISC_CTL_FIELD_MSMC_PARITY_BLOCK_MSB    12
#define DEVICE_MISC_CTL_FIELD_MSMC_PARITY_BLOCK_LSB    12

#define DEVICE_MISC_CTL_VAL_MSMC_BLOCK_RESET            1
#define DEVICE_MISC_CTL_VAL_MSMC_ALLOW_RESET            0



#define DEVICE_TIMER64_BASE           0x02280000
#define DEVICE_TIMER_INPUT_DIVIDER    6             /* chip clock 6 drivers the timer, is divide by 6 */
 
/* Interrupt subsystem */
/* Interrupt controller outputs are for core 0 only !!! */
#define DEVICE_INT_INTC0_OUT_0      chipIntcOut(0)  /* Different for hawking master die and napier-lite master die */
#define DEVICE_INT_INTC0_OUT_1      chipIntcOut(1)
#define DEVICE_INT_INTC0_OUT_2      chipIntcOut(2)
#define DEVICE_INT_INTC0_OUT_3      chipIntcOut(3)

#define DEVICE_INT_PCIE_LEGACY_A    DEVICE_INT_INTC0_OUT_0
#define DEVICE_INT_PCIE_LEGACY_B    DEVICE_INT_INTC0_OUT_1
#define DEVICE_INT_PCIE_LEGACY_C    DEVICE_INT_INTC0_OUT_2
#define DEVICE_INT_PCIE_LEGACY_D    DEVICE_INT_INTC0_OUT_3

#define DEVICE_INT_IPC              chipIntctlIpc()
#define DEVICE_INT_VUSR             DEVICE_INT_INTC0_OUT_0
#define DEVICE_INT_TIMER0           64

 
/* MSMC Size fields used in the code */
#define DEVICE_MPAX_MSMC_BLOCK_SIZE_2_MB        0x14
 
/* The VUSR segment information. Segments are setup for the local L2s,
 * the MSMC, the DDR config space, and DDR. The maximum block is 4 Mb */
#define DEVICE_VUSR_SERDES_BASE(x)         (0x0231a000 + ((x) * 0x2000))
#define DEVICE_VUSR_SERDES_STATUS_BASE(x)  DEVICE_VUSR_SERDES_BASE(x)
#define DEVICE_VUSR_N_RX_SEGS    64
/* DEVICE_VUSR_SEGINFO in device specific map file */
 
 




/* DDR3a base address */
#define DEVICE_EXT_DDR3A_START_ADDR ((UINT32)0x80000000)

/* EMIF25 xip address */
#define DEVICE_XIP_START_ADDR       ((UINT32)0x30000000)
#define DEVICE_XIP_END_ADDR         ((UINT32)0x40000000)

#define DEVICE_XIP_CS2_START_ADDR   ((UINT32)0x30000000)
#define DEVICE_XIP_CS3_START_ADDR   ((UINT32)0x34000000)
#define DEVICE_XIP_CS4_START_ADDR   ((UINT32)0x38000000)
#define DEVICE_XIP_CS5_START_ADDR   ((UINT32)0x3c000000)
 
 
/* Serdes internal configuration. */
#define DEVICE_SERDES_VALID_MULTS_X4   {    4*4,  5*4,  6*4,    8*4, 8.25*4, 10*4, 12*4,   \
                                         12.5*4, 15*4, 16*4, 16.5*4,   20*4, 22*4, 25*4 }

#define DEVICE_SERDES_MULT_BITS   { 0x10, 0x14, 0x18, 0x20, 0x21, 0x28, 0x30,           \
                                    0x32, 0x3c, 0x40, 0x42, 0x50, 0x58, 0x64 }
                                    
#define DEVICE_SERDES_DATA_RATES_X4   {  {  2,  4,  8,  64  },  /* Draco rates */     \
                                         {  1,  2,  4,   8  }   /* Rincewind rates */ }
                                         
/* Only one SERDES type used */
#define DEVICE_SERDES_TYPE_SNOWBUSH     0

#define DEVICE_VUSR_SERDES_TYPE         DEVICE_SERDES_TYPE_SNOWBUSH
#define DEVICE_SRIO_SERDES_TYPE         DEVICE_SERDES_TYPE_SNOWBUSH
#define DEVICE_PCIE_SERDES_TYPE         DEVICE_SERDES_TYPE_SNOWBUSH

#define DEVICE_SERDES_MAX_INT_CLOCK_KHZ     3125000     /* 3.125 GHz */
#define DEVICE_SERDES_MIN_INT_CLOCK_KHZ     1500000     /* 1.5 GHz */
#define DEVICE_SERDES_VRANGE_THRESHOLD_KHZ  2170000    /* Internal operation below this requires vrange to be set */


/* PASS */
#define DEVICE_PA_RUN_CHECK_COUNT                   100         /* Number of loops to verify PA firmware is running */
#define DEVICE_PA_PLL_BASE                          0x02620358
#define DEVICE_PA_PLL_NUM                           1


/* PA streaming switch config */
#define DEVICE_PSTREAM_CFG_REG_VAL_ROUTE_PDSP0      0


/* Timeout loop count for emac reset */
#define DEVICE_EMACSL_RESET_POLL_COUNT  10000


/* Queue manager configuration */
#define DEVICE_QM_MANAGER_BASE          0x02a02000
#define DEVICE_QM_DESC_SETUP_BASE       0x02a03000
#define DEVICE_QM_MANAGER_QUEUES_BASE   0x02a80000
#define DEVICE_QM_MANAGER_Q_PROXY_BASE  0x02a40000

#define DEVICE_QM_NUM_LINKRAMS          2
#define DEVICE_QM_NUM_MEMREGIONS        20

/* Although there are 2 QMs in the system, the boot code will only setup 1 */
#define DEVICE_NUM_QMS          1
#define DEVICE_QMSLV_BASE(x)    0x23a80000

/* PCIe configuration. Device specific PCIE registers are in its own _map file */
#define DEVICE_PCIE_N_LANES              2
#define DEVICE_SLEEP_PCIE_EVENT          (0x7f << 4)         /* Wake on interrupts 4,5,6,7,8,9,10 */
#define DEVICE_PCIE_SERDES_STATUS_BASE   DEVICE_PCIE_SERDES_BASE



/* I2C */
#define DEVICE_I2C_BASE(x)     (0x2530000 + ((x) * 0x400))
#define DEVICE_I2C_TARGET_MODULE_FREQ_MHZ_Q1  20  /* 10.0 MHz (x2 for Q1 format) */

/* Sleep configuration */
#define DEVICE_SLEEP_SLEEP_EVENT        (1 << 4)             /* Wake on interrupt 4 */

/* Cache base */
#define DEVICE_CACHE_BASE          0x1840000


/* UART definitions moved to device specific file*/


/* VUSR  base */
#define DEVICE_VUSR_BASE(x)     (0x21400000 + ((x) * 0x100))

/* VUSR register values */
/* Ctrl: Intlocal(14)   = 1
 *       Intenable(13)  = 1
 *       Intvec(12:8)   = 0x1f  - module status ints to int 31 
 *       Int2cfg(7)     = 1
 *       Serial stop(2) = 0
 *       loopback(1)    = 0
 *       reset(0)       = 0
 */
#define DEVICE_VUSR_REG_CTRL_VAL    0x00007f80

/* Rx address selector. Priv ID 0 is used, security disabled,
 * and the window size is set to 0x00400000. This size divides
 * the 256 Mbs of VUSR mapped ram into 64 segments */
#define DEVICE_VUSR_REG_RXADDR_SEL_VAL  0x00000006

/* The VUSR interrupt is mapped to vector 4, ipc to 5 and timer to 6 */
#define DEVICE_SLEEP_VUSR_EVENT  (7 << 4)   /* Wake on interrupts 4,5,6 */

/* Timer interrupt event */
#define DEVICE_INT_TIMER_LOCAL  64

/* SPI configuration */
#define DEVICE_SPI_BASE(x)              (0x21000400 + ((x) * 0x200))
#define DEVICE_SPI_MOD_DIVIDER          6               /* sysclock 6, which is div by 6 */
#define DEVICE_SPI_MAX_DIVIDER          0xff            /* The maximum value that should be programmed into 
                                                         * the SPI divider */
/* EMIF 4 */
#define DEVICE_EMIF4_REV_EMIF4V                                 /* An emif4v is used */
#define DEVICE_EMIF4_BASE               0x21010000              /* These are the emif configuration registers */
#define DEVICE_EMIF4_PHY_BASE           0x02329000              /* The DDR3 phy base */
#define DEVICE_CHIP_CONFIG_EMIF_CFG(x)  (DEVICE_EMIF4_PHY_BASE + ((x)*4))    /* The Phy DDR3 config registers */

/* Interrupt combiner locations */
#define DEVICE_INTC_BASE(x)     (0x2600000 + ((x) * 0x4000))

/* Intc0 system event numbers, same for both MMI and WBI */
#define DEVICE_INTC0_SYSTEM_INT_VUSR(x)         ((x)    == 0 ? 111 : 365)

/* Intc0 output channel mappings. These are use chosen and must map
 * to the chip specific desired system interrupt controller */
#define DEVICE_INTC0_PCIE_LEGACYA_OUT_CHANNEL   0
#define DEVICE_INTC0_PCIE_LEGACYB_OUT_CHANNEL   1
#define DEVICE_INTC0_PCIE_LEGACYC_OUT_CHANNEL   2
#define DEVICE_INTC0_PCIE_LEGACYD_OUT_CHANNEL   3
#define DEVICE_INTC0_VUSR_OUT_CHANNEL           0


/* A one IPC to core mapping is used here */
#define DEVICE_INT_GIC_PIEVENT_IPC(x)           (4 + 32 + (x))

/* The Timer 0 interrupt is used for any modes with timeout. Only TIM12 interrupt is used. */
#define DEVICE_INT_GIC_PIEVENT_TIMER(x)         (80 + 32 + (2 * (x)))

/* The Hyperlink interrupt */
#define DEVICE_INT_GIC_PIEVENT_HYPER(port)      (387 + +32 + (port))

/* SRIO */
#define DEVICE_RAPIDIO_BASE             0x02900000
#define DEVICE_SRIO_SERDES_BASE         0x0232c000
#define DEVICE_SRIO_SERDES_STATUS_BASE  DEVICE_SRIO_SERDES_BASE
#define DEVICE_RIO_N_LANES              4
#define DEVICE_RIO_MAX_PORTS            4
#define DEVICE_SLEEP_RIO_EVENT          (1 << 4)         /* Wake on interrupt 4 (will be the doorbell) */

#ifdef _TMS320C6X
 #define DEVICE_INT_RAPIDIO_DOORBELL     20               /* Device event 20 for GEM, 24 for tetris */
#else
 #define DEVICE_INT_RAPIDIO_DOORBELL     24               
#endif

/* DDR PLL */
#define DEVICE_DDR_PLL_BASE             0x02620360
#define DEVICE_DDR_PLL_NUM              2
#define DEVICE_DDRb_PLL_BASE            0x26200368
#define DEVICE_DDRb_PLL_NUM             3

/* ARM PLL */
#define DEVICE_ARM_PLL_BASE             0x02620370
#define DEVICE_ARM_PLL_NUM              4

/* E-fuse ready */
#define DEVICE_REG_INT_SPARE0                   0x02620c70
#define DEVICE_FIELD_SPARE0_EF_LOAD_DONE_MSB    7
#define DEVICE_FIELD_SPARE0_EF_LOAD_DONE_LSB    4
#define DEVICE_FIELD_VAL_EF_LOAD_DONE           0xf


/* Tetris PSC */
#define DEVICE_TETRIS_PSC_BASE                      0x01e80000
#define DEVICE_TETRIS_PSC_TRANSITION_LOOP_COUNT     1000        /* Number of passes through the poll loop */
#define DEVICE_TETRIS_PSC_TRANSITION_DELAY_COUNT    1000        /* Cycles per poll */


/* XMC configuration used to get access to DDR3 configuration registers */
#define DEVICE_REG_XMPAX_BASE   0x08000000
#define DEVICE_REG_XMPAX_L(x) *((volatile unsigned int *)(DEVICE_REG_XMPAX_BASE + 0 + (8*(x))))
#define DEVICE_REG_XMPAX_H(x) *((volatile unsigned int *)(DEVICE_REG_XMPAX_BASE + 4 + (8*(x))))


/* MSMC config range */
#define DEVICE_MSMC_CFG_BASE          0x0bc00000

/* SMS configuration registers */
#define DEVICE_NUM_SMS_PRIV_IDS       16
#define DEVICE_REG_SMS_BASE           0x0bc00200
#define DEVICE_REG_SMS_L(privid,idx)  *((volatile unsigned int *)((DEVICE_REG_SMS_BASE + 8) + ((privid) * 64) + ((idx) * 8)))
#define DEVICE_REG_SMS_H(privid,idx)  *((volatile unsigned int *)((DEVICE_REG_SMS_BASE + 4) + ((privid) * 64) + ((idx) * 8)))
#define DEVICE_REG_SMS_LOCK           *((volatile unsigned int *)(0x0bc00068))
#define DEVICE_REG_SMS_UNLOCK         *((volatile unsigned int *)(0x0bc0006C))
#define DEVICE_REG_VAL_SMS_KEY(x)     (0x2cd10000 | (1 << (x)))    /* Unlocks for priv ID x */

/* SES configuration registers */
#define DEVICE_NUM_SES_PRIV_IDS       16
#define DEVICE_REG_SES_L(privid,idx)  *((volatile unsigned int *)(0x0bc00600 + ((privid) * 64) + ((idx) * 8)))
#define DEVICE_REG_SES_H(privid,idx)  *((volatile unsigned int *)(0x0bc00604 + ((privid) * 64) + ((idx) * 8)))
#define DEVICE_REG_SES_LOCK           *((volatile unsigned int *)(0x0bc00074))
#define DEVICE_REG_SES_UNLOCK         *((volatile unsigned int *)(0x0bc00078))
#define DEVICE_REG_VAL_SES_KEY(x)     (0x2cd20000 | (1 << (x)))   /* Unlocks for priv ID x */


/*******************************************************************************
 * PRIVIDs are assignable. The following values are the hardware defaults
 *******************************************************************************/
#define DEVICE_PRIVID_GEM_BASE   0
#define DEVICE_PRIVID_ARM        8
#define DEVICE_PRIVID_SRIO       9
#define DEVICE_PRIVID_HYPER     14


/* Device priv ids are programmable. Default values are shown */
#define DEVICE_PRIVID_DEFAULT_GEM(x)    (DEVICE_PRIVID_GEM_BASE + (x))
#define DEVICE_PRIVID_DEFAULT_ARM(x)    DEVICE_PRIVID_ARM
#define DEVICE_PRIVID_DEFAULT_SRIO      DEVICE_PRIVID_SRIO
#define DEVICE_PRIVID_DEFAULT_QM(x)     ((x) + 9)
#define DEVICE_PRIVID_DEFAULT_HYPER     DEVICE_PRIVID_HYPER


/*******************************************************************************
 * Master IDs
 *******************************************************************************/
#define DEVICE_MASTERID_GEM_0         0
#define DEVICE_MASTERID_GEM(x)        ((x) + DEVICE_MASTERID_GEM_0)
#define DEVICE_MASTERID_GEM_CFG_0     16
#define DEVICE_MASTERID_GEM_CFG(x)    ((x) + DEVICE_MASTERID_GEM_CFG_0)

#define DEVICE_MASTERID_ARM_0         8 
#define DEVICE_MASTERID_ARM(x)        ((x) + DEVICE_MASTERID_ARM_0)
#define DEVICE_MASTERID_ARM_CFG_0     8
#define DEVICE_MASTERID_ARM_CFG(x)    ((x) + DEVICE_MASTERID_ARM_CFG_0)

#define DEVICE_MASTERID_SRIO          30
#define DEVICE_MASTERID_PCIE          31
#define DEVICE_MASTERID_HYPER(port)   (28 + (port))

/*********************************************************************************
 * Domain IDs
 *********************************************************************************/
#define DEVICE_DOMAINID_SRIO        5
#define DEVICE_DOMAINID_SRIO_CDMA   8
#define DEVICE_DOMAINID_PCIE        13
#define DEVICE_DOMAINID_HYPER(port) 18



/* System PLLs */
#define DEVICE_MASTER_PLL_BASE           0x2310000
#define DEVICE_SYS_PLL_NUM      0
#define DEVICE_PLL_BASE(x)               ((x) == DEVICE_SYS_PLL_NUM  ? DEVICE_MASTER_PLL_BASE :    \
                                         ((x) == DEVICE_PA_PLL_NUM   ? DEVICE_PA_PLL_BASE     :    \
                                         ((x) == DEVICE_DDR_PLL_NUM  ? DEVICE_DDR_PLL_BASE    :    \
                                         ((x) == DEVICE_DDRb_PLL_NUM ? DEVICE_DDRb_PLL_BASE   :    \
                                                                       DEVICE_ARM_PLL_BASE))) )
                                         
/* only the PA PLL requires setting of the outsrc bit */                                         
#define DEVICE_PLL_OUTSRC(x)            (x) == DEVICE_PA_PLL_NUM ? TRUE : FALSE
                                         
                                         
#define DEVICE_MAIN_PLL_CTL_0           0x02620350
#define DEVICE_MAIN_PLL_CTL_1           0x02620354

/* PSC */
#define DEVICE_PSC_BASE                 0x02350000


/* E-fuse MAC ID */
#define DEVICE_REG_MACID1                       *((volatile unsigned int *)0x2620110)
#define DEVICE_REG_MACID2                       *((volatile unsigned int *)0x2620114)
#define DEVICE_REG_VAL_MACID2_BCAST_MASK        0x00010000
#define DEVICE_REG_VAL_MACID2_BCAST_ENABLE      0x00000000

/* Interrupt combiner event numbers */
#define DEVICE_INT_EVENT_COMBINE_0  0
#define DEVICE_INT_EVENT_COMBINE_1  1
#define DEVICE_INT_EVENT_COMBINE_2  2
#define DEVICE_INT_EVENT_COMBINE_3  3


/* External memory start address, used for hibernation recovery address check */
#define DEVICE_EXT_START_ADDR       ((UINT32)0x80000000)

/* Base address of emif25 controller */
#define DEVICE_EMIF25_BASE          0x21000a00


/* The following values define the memory blocks that are available to for download when the ARM is
 * the boot master. Values outside this range will be rejected. */
#define DEVICE_ARM_MASTER_DSP_START(x)  (0x10800000 + ((x) << 24))
#define DEVICE_ARM_MASTER_DSP_END(x)    (0x108ef000 + ((x) << 24))
 

/* SRIO CDMA configuration */
#define DEVICE_SRIO_CDMA_GLOBAL_CFG_BASE   0x02901000
#define DEVICE_SRIO_CDMA_TX_CHAN_CFG_BASE  0x02901400
#define DEVICE_SRIO_CDMA_RX_CHAN_CFG_BASE  0x02901800
#define DEVICE_SRIO_CDMA_RX_FLOW_CFG_BASE  0x02902000

#define DEVICE_SRIO_CDMA_RX_NUM_CHANNELS   16
#define DEVICE_SRIO_CDMA_RX_NUM_FLOWS      20
#define DEVICE_SRIO_CDMA_TX_NUM_CHANNELS   16

/* Memory bases */
#define DEVICE_BASE_L2          0x00800000
#define DEVICE_BASE_DDR3        0x80000000
#define DEVICE_BASE_DDR3B       0x60000000
#define DEVICE_BASE_MIN_DDR3    DEVICE_BASE_DDR3B
#define DEVICE_END_DDR3         0xFFFFFFFF




/* Secctl */
#define DEVICE_SEC_SCAN_BASE 0x02500000

/* Keys in chip level registers */
#define DEVICE_PUBLIC_KEY_BASE   (DEVICE_SEC_SCAN_BASE + 0x900) /* no error correction on this key */

#define DEVICE_PUBLIC2_KEY_BASE  (DEVICE_SEC_SCAN_BASE + 0xa00)
#define DEVICE_PUBLIC2_BCH_BASE  (DEVICE_SEC_SCAN_BASE + 0xa40)

#define DEVICE_CEK_KEY_BASE      (DEVICE_SEC_SCAN_BASE + 0x980)
#define DEVICE_CEK_BCH_BASE      (DEVICE_SEC_SCAN_BASE + 0x9c0)

#define DEVICE_CEK2_KEY_BASE     (DEVICE_SEC_SCAN_BASE + 0xa80)
#define DEVICE_CEK2_BCH_BASE     (DEVICE_SEC_SCAN_BASE + 0xac0)

#define DEVICE_KEK_KEY_BASE      (DEVICE_SEC_SCAN_BASE + 0x880) /* no error correction on this key */




/* ARM Endian Configuration registers */
#define DEVICE_ARM_ENDIAN_CFG(set,reg)      *((unsigned int *)(0x2620400 + ((set) * 0x10) + ((reg) * 0x4)))
#define DEVICE_ARM_ENDIAN_CFG_NUM_SETS      8
#define DEVICE_ARM_ENDIAN_CFG_ENABLE        0
#define DEVICE_ARM_ENDIAN_CFG_DISABLE       0xffffffff


/* GIC Configuration */
#define DEVICE_MAX_GIC_GROUPS           2
#define DEVICE_GIC_GROUP_NON_SECURE     1

#define DEVICE_MAX_GIC_INTNUMS          480

#define DEVICE_GIC_BASE                 0x2560000

/*********************************************************************************
 * EDMA 0 is used for memory scrub
 *********************************************************************************/
#define DEVICE_MEMSCRUB_EDMA_BASE   0x2700000

/*********************************************************************************
 * IPC index for ARM core 0
 *********************************************************************************/
#define DEVICE_IPC_IDX_ARM_0        8


/************************************************************************************
 * Individual core non-secure state
 ************************************************************************************/
#define DEVICE_ADDR_DSP_SECURE_STAT     0x2620800
#define DEVICE_ADDR_DSP_SECURE_EN(x)    (0x2620804 + ((x)*4))

#define DEVICE_VAL_DSP_SECURE_STAT_NONSEC   0


/************************************************************************************
 * FUNCTION PURPOSE: Read contiguous bits from devstat
 ************************************************************************************
 * DESCRIPTION: Bit fields are extracted from the devstat registers
 ************************************************************************************/
#ifdef BOOT_READ_BITFIELD
static inline UINT32 ireadDevstatBits (UINT32 msb, UINT32 lsb)
{
    UINT32 devstat;
    UINT32 v;

    devstat = DEVICE_REG_DEVSTAT;
    v = BOOT_READ_BITFIELD (devstat, msb, lsb);

    return (v);

} /* ireadDevstatBits */
#endif



#endif /* _KEYSTONE2_MAP_H */






